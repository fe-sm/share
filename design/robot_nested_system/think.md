# 机器人 - 无人柜面 - 柜员机 前端思考/设计

> 机器人无人柜面柜员机提出的，按照权限划分、子系统可单独运行且可作为主系统的子模块。

> 不同于服务端的微服务设计，服务端的每个服务都有自己的容器。但是前端的话，所有的子系统需要可以单独运行（有属于自己的容器），但是又需要作为主框架的子系统（共享一个容器）。

> 可以嵌入的系统不限制框架的使用。

> 为了达到这样的目的，`iframe` 方案是最简单的，可以达到每个系统都是自己单独的容器。但是考虑到 `iframe` 的繁琐以及对 `iframe` 的抗拒，且有些子系统需要对全局环境造成一定的副作用（必须要影响全局环境的情况），这种时候造成子系统两者的分离（子系统本身以及 `pre-install` 的过程），而且并不一定很好控制。所以我们考虑的是主框架（即使潜入了子系统）以及子系统均是**SPA**。

为了实现**插件化**且**可独立运行**的目标，经过思考，得出以下考虑点：

- 采用**预编译方案** + **在线编译方案**。不同的子系统为了达到可独立运行的目标，必然需要一个模块化方案。在子系统的开发中，推荐使用 `webpack` / `browserify` 的模块预编译方案。优点有很多，包括 `tree shaking`（该特性基于 `es6 module`） + `code split`（ `r.js` 貌似也能做，但是很繁琐） + `lazy loading`（ `require` 也是可以的，但是结合 `bundle` + `code split` 就比较麻烦。第二点，不同的子系统为了可作为插件嵌入到主框架中，也即此时静态资源（ `assets` ）不是在一处，那么模块预编译方案肯定是不行的。所以此时主框架采用在线编译方案，推荐采用 `cmd` 规范的实现 `seajs`。该项还有两个问题需要考虑：
    + 如何达到 `webpack` + `require/sea` 很好配合使用。解决方案：`webpack` 的 `libraryTarget` 设置为 `umd` 即可。
    + 子系统作为插件，嵌入到主框架的场景中，如果子系统增加了 `code split` 的处理过程，如何保证懒加载其它模块时，其它模块的路径问题。这个问题目前还没想好，但是有规避措施，也就是不使用 `code split` 特性。

- 一个子系统为了实现自身可以独立运行，那么必须需要一个**页面的入口**，也即 `index.html`，同时需要处理该页面的脚本（ `app.js` ）以及样式（ `app.css` ）。但是，这样我们得考虑很多很多的东西。
    + `index.html` 包含的是整个应用所需要的 `html`，包括 `header`、`nav`、`footer` 以及 `content` 等。但是嵌入到主框架时，我们并不能直接去使用它。
    + `app.js` 会有对非 `content` 内容进行操作的脚本，嵌入时这些脚本是不需要的，所以我们是否需要对这些脚本进行区分。但是如果是组件式开发方案的话，会简单一点点，我们只用导出必要的 `content` 内容组件以及其它的一些资源。
    + `app.css` 会包含 `reset/normalize` 样式以及一些特有样式。嵌入到系统中，我们需要的只有特有的样式，主框架自身只需要包含 `reset/normalize` 的样式以及主框架自身特有的样式即可。所以我们需要去拆分 `css`。而且系统的特定样式最好需要使用前缀 `prefix` 来区分，防止冲突或者覆盖（前缀的话可以考虑工具处理）。

- 状态管理。每一个系统都有自身的状态，有些是需要影响到全局的，有些不是。在主框架中，我们如何去管理这些状态。暂时可以分为全局 `store` 以及 分子系统的 `store`。

- 系统需要去设置一些监听，或者与其它系统进行通信，所以我们需要一个全局的 `Observer`。但是考虑到子系统也是可能需要的，所以可能我们也需要分子系统的 `Observer`。

- 每一个子系统在嵌入到主框架时，可能需要做一些预处理的事情，在卸载时可能做一些后处理的过程。所以可能需要考虑划分三个阶段：`pre-install`、`install`、`post-install`。

- 考虑到**插件**或者**中间件**这样的名词，我们可以考虑使用 `App.use`、`Module.install` 这样的 `api`。

- `css` 的预加载。为了防止 `repaint` 以及 `reflow`，我们可能需要的是预加载所有嵌入的子系统的 `css`。（问题：`link` 删除之后样式是否存在。答案：不存在。）

- 主框架来引入子系统的 `css` 以及 `scripts` 时，路径问题可能需要统一。比如我们可以获取的只有系统的 `url`，然后 `css` 以及 `controller` 对应为 `${url}/${type}.${ext}`，减少配置。

- 不同系统的 `loading` 问题（样式、范围）。

- 由于是**SPA**，那么路由肯定是必须的。如果主框架也使用了**[hash]**，且子系统也需要使用，那就尴尬了。所以主框架仅仅做最简单的控制（大局管理），而不用去管**[hash]**。

- 同样的，既然是**SPA**，那么不同系统的初始路由配置也需要确定。
