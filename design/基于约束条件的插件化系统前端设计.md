# *基于约束条件的*插件化系统前端设计

[@bqliu](https://github.com/bq-hentai)

> 假想的背景：某公司在做一个资源配置系统 A，目标是一个平台类型的项目，同时又有另外一个系统 B，其内部有一个小的资源配置系统 C。发展着发展着，B系统需要的一些功能 C不能满足，而 A可以满足，这时候从产品层面，就想直接集成 A系统，服务端的话主要保证数据层面blabla ok就行，前端 web 应用这块，也要能集成好，这时候怎么做呢。
 
> **NOTE** 本文档内基本不包含任何具体实现，但是有实际的实践案例。重要的在于逻辑流程，有空我会整个 seed project。

## 术语

这里所说的术语是本文档内的一些名词以及其解释，主要有：

- 约束条件。约束条件指的是该方案的一些约束，具体的细节在后续会详细解释。
- 插件化系统。指的是一个 web应用可自己单独运行，也能内嵌在其它系统中执行，就像一个插件一样，可以方便的装载和卸载。

另外，该方案是仅考虑前端设计，不考虑后台是一个还是多个，多个的话采用代理来解决，并非本方案的重点。

最后，本方案中会出现一些类似于 A、B、C、D 这些大写字母，代表 A、B、C、D 系统。每个系统都是一个插件化系统。

## 探索

现在，我们慢慢探索一步步去解决假想的背景带来的问题。

### Mtd0

如果是最简单的集成的话，那就 ———— `<a href="link_to_b_system" target="_blank">跳转到 B</a>`。

额，这并不是皮一下，这对前端来说是最简单的方案。类似于一个统一门户，要进到什么系统就进到什么系统就好咯，后台数据打通了就行了。只不过为了更好的用户体验，我们还得集成一下 sso，不然跳来跳去*可能*还得重新登录，这多难受。

现在很多网站都基于 SSO，登入一个系统之后，其它各个子系统之间也能互相跳转而且不需要登录。

额，也就是说部分场景这样集成就行了，方便快捷，也没啥缺点（缺点最多也就是来回跳转标签页有点难受，另外就是占用内存比较高（如果同时打开多个标签页的话））。

但是......总感觉前端基本上不用做啥......而且一眼看过去，这办法有点low-，-（当然了能解决问题就行，low不low是其次）

额，不管怎样，我们也来想想看其它的方案吧。

### Mtd1

既然是系统嵌套，那自然而然，有个最传统的模式 ———— iframe。直接将 A 用 iframe 嵌入到 C 中。

这种模式就不用细说了，基本上现代很少有新系统会这样做了，但是在一些细分场景（比如内嵌播放应用），iframe 还是一个不错的方案。

补充一下优缺点：

- 优点主要是简单快捷，一个 iframe 就能搞定，同时系统内部通过 iframe 可以起到样式、脚本隔离，防止相互影响。
- 缺点的话也很清晰，iframe 体验并不是非常好，性能一般来说肯定会略差一些，另外，如果存在跨系统通信可能就比较麻烦。

另外，在某些传统应用中，存在应用主框架内嵌各个 iframe，通过菜单切换来切换 iframe 的 src，然后进一步我们每个菜单页面就是一个完整的页面。市面上 [layuiAdmin](ttps://www.layui.com/admin/) 以前就是这么干的，现在仍旧存在 iframe 版本，但同时也存在*真正*的单页版本。

当然，在这个场景下，因为所有页面都是完整的一个页面，所以一些基础的代码/样式之类的文件需要重新Load。由于这个问题，可能有些人会说资源加载会非常慢。但是在我看来这个除非资源数目较多，不然基本没什么影响。因为资源可以加缓存策略解决，但是较多资源的话不太好直接断定一定会有问题，当然能肯定的是，资源加载肯定会更慢一些（哪怕是从本地缓存中获取）。

其实在这个方案下，我们可以考虑一下集成方案，就是如果真的有两个系统 A 和 B 是按照这种模式来做的，那我们如何将其中一个（比如B）嵌入到另一个（A）中呢。

#### 集成过程

根据上面的描述，我们知道其实只用合并一下菜单项，然后合并一下具体的 pages，整个也就集成了。另外，考虑到后管很多会用到权限菜单，那就是说我们在权限菜单中配置好了，然后菜单根据权限菜单数据生成，用户点击某个菜单项，然后内容主体切换/新建一个 iframe 就好了，但是相对的，需要知道具体跳转的地址。比如权限数据如下：

```javascript
const menu = [
  { id: 0, pid: null, name: "首页", isLeaf: true, link: "/index.html" },
  { id: 1, pid: null, name:  "配置", isLeaf: false, children: [ { id: 2, pid: 1, name: "F配置", isLeaf: true, link: "/config/fconfig.html" } ] }
]
```

菜单按照 `menu` 渲染好之后，然后点击每一个菜单项，修改内部的 iframe 的 `src` 实现跳转，或者增加一个 `src` 为 `link` 的 iframe。

如果我们集成了 sso，我们甚至可以接入其它域的系统。

另外我们也能发现，我们如果想要通信，都得跨 iframe，这样的话就得通过 parent/top/postMessage 来进行通信，这样就比较麻烦了。

### Mtd2

其实 [Mtd1](#mtd1) 挺好的，但是考虑一下优点中的环境隔离，防止互相影响，其实在一个体系/系列的产品中，设计风格应该是统一的，另外，模块化开发也能缓解对全局环境的影响。也就是说现在这个优点基本上吸引力并不会非常非常大。

另外，我们考虑到每个内容是一个 iframe 来呈现的，但是实际上，不就是一个**组件**么。我们只是按需去展示该展示的组件就好了，那我们能想到什么？

这不就是 **动态组件** 或者 **SPA路由** 么。

我们按需/按条件去渲染相对应的组件，我们只要知道具体的组件就好了，维护一个映射关系，搞个动态组件不难，比如这样的一个映射关系：

```javascript
const CONDITION_COMPONENT_MAP = {
    index: IndexComponent,
    fconfig: Fconfig
}
```

权限数据中配置好 key，然后动态切换要渲染的内容组件即可。

额，不过...如果内部有导航就稍微可能显得比较乱，毕竟每个系统都是 SPA啊，内部有导航很正常=，=

诶诶诶，内部有导航，其实我们在上面 `CONDITION_COMPONENT_MAP` 中映射的组件就是内部导航的组件呀，那我们为什么还要搞动态组件呢？直接路由导航不就行了=，=

这样的话，等于内部映射关系和组件切换让 `Router` 给我们做了。

这样的话，集成起来就简单了，权限菜单配置要跳转的路由，然后，点击菜单项...跳转就行了......

这样岂不就是 iframe 版本-.-

但是没有 iframe 那样需要创建一个单独的环境，资源加载也不会重复，通信问题也变得异常简单 ———— 因为都在一起呀 O.O

而且如上所说，统一的规范 + 模块化让我们也不用太操心互相影响。

> 当然内部如果需要更改同一个实例的话，还得注意点，要么创建多实例，要么保持一致。

### 总结

经过探索，从 Mtd0 到 Mtd2，我们会发现 Mtd2 中提出的采用基于 **SPA路由** 是一种比较好的方案，能在资源加载、通信这块比较简单。那我们就来深入细节看看这个方案细节上如何设计。

## 基于 **SPA路由** 的可嵌入系统前端详细设计

### 开始之前

#### 版本控制

为了简化开发、合并、部署、公用业务组件等使用，可以考虑代码都放在一个 repo 里面。但是这对版本管理工具（svn/git）的使用/工作流有一定的要求 —— 必须严格基于分支来开发，而且分支要能良好的管理。

> 其实最好的肯定是能分成若干个 repo 来搞 hhh。
> 也可以多个 repos，但是相对来说，也有一点麻烦，比如划分成 common、A、B 三个 repo，然后 部分路径问题 可能需要去解决，然后，构建之类的流程也要考虑，还有就是如果走 ci，还得多考虑考虑，这个我之前没继续往下想，之后可以花点时间考虑一下。

就分支的话可以考虑以下的设计（层级关系见列表层次）：

- Trunk(A)(deploy)
    - Branches/A/deploy
        - Branches/A/dev
            - Branches/A/feat/**
            - Branches/A/hotfix/**
        - Branches/A/tags/**
    - Branches/B/deploy/**
        - Branches/B/tags/**
        - Branches/B/dev/**
            - Branches/B/feat/**
            - Branches/B/hotfix/**

trunk 其实可以指定为一个全集，用于任意一个父系统。不过超多系统的话，还是支持多 repos 好。

#### 开发模式

由于是共享一个环境，所以开发肯定也得有一些约束。

各个系统的前端分别开发各自的项目，如果有跨项目的公共组件，就提取出来放在 common 中，但是必须经过严格的审核。

综合来看，如果有任何以下行为，都需要经过严格审核：

1. 修改通用模块/组件
2. 修改构建脚本
3. 增加对全局环境造成影响的代码，包括但不限于全局的组件样式覆盖、window对象的修改，第三方库（会影响全局环境）的引入
4. 其它可能的行为

### 开发详细方案

在SPA中有几点非常重要 ———— **路由** 和 **状态** ———— 如果我们能规划好路由和状态，我们的应用基本已经成功一半。

> 注意部分应用很简单，虽然是 SPA，但是很简单，不需要接入路由这个概念。

路由牵涉到页面映射、状态牵涉到应用内部共享数据，从可嵌入系统的角度来看，我们只要能把路由合并、状态合并，那我们的应用是不是也基本成功了一半？

答案当然是不正确的啦，这时候我们并没有成功一半，但是基础框架（骨架）结构/层次设计中最重要的一部分已经完成。

#### 页面骨架

我们可以建立一个通用的页面骨架（既然是可以内嵌且能独立运行的系统，骨架基本都是一致的），然后各个子系统只需要能单独开发各个子系统具体的内容模块即可。

我们知道，其实所谓的内容模块，其实只是对应着一个个的路由以及相应的路由组件，所以如果能建立这样一个骨架，那各个子系统就只需要开发一个个特定路由对应的组件。

对于这样的骨架的实现其实很简单，我们抽象出来 Menu、Header 和 Footer，组建成一个页面的基础的布局，剩下的根据 MenuItem 的跳转进一步跳转到内部的子路由中，子路由中的内容即各个子系统对应的组件了。

当然存在一些特例，比如存在一些通用路由跳转，比如 404 这类的。这个考虑到一致性，所以不同的子系统如果需要用肯定也会用一致的，所以可以考虑增加一个公共模块/子系统 common。

结合前面的骨架来看，我们可以发现，骨架的实现可以放在 common 内，这样 common 还能承载另外一个含义 ———— 应用启动模块，下面会介绍。

#### 一些问题

初步看来，上述的骨架/模式能满足开发。但是仔细考虑的话，会发现这样的话有一些问题，比如如何集成统一的开发、构建流。主要存在几个问题：

- 如何区分各个不同的系统。因为我们需要按需打包。
- 如何根据环境（不仅是 dev/prod 环境区分，还有不同系统间的区分）按需加载资源。
- 如何将状态、路由等资源合并。
- 其它的和骨架无关的问题比如有如何控制好全局环境，像 css 那样直接影响全局环境的更是容易出问题。

对于如何区分不同的系统，我们可以由 dev 和 prod 环境可以联想到，我们可以增加一个环境状态，比如 SYS，通过 SYS 来指定我们需要操作哪个项目。

对于按需加载资源这个问题，转换一下思路就知道其实是按条件加载，但是难点在于 import 是静态的，且无法结合 if 等条件，但是我们可以结合 条件require 和 dynamic import 方式来做。具体实现后面再介绍。

第三个问题是如何将状态、路由等资源合并，这个问题有点麻烦，主要在几个方面：

1. 路由这块，A 嵌入到 B 中，可能会导致层级变化，所以路由这块需要控制好（tip: 善用 name）。
2. store 这块，为了保证互不影响，且为了简化（不处理是否需要增加 namespace 导致的两种情况 ———— 有 namespaced 和无 namespaced），所以必须增加 namespaced module。同时对于 App 内状态，可以增加一个 common 模块，common 模块不需要 namespace，直接作为 root。
3. 其它的资源，比如 bus、api 这块，可以采用如上类似的做法。

综上，也就是以 common + 特定的资源模块合并的方式，辅以按需加载，最终能导出相应的真正需要的资源。

其中存在一些细节问题，比如样式文件的冲突。这个后续逐一细化解决（辅以部分约束）。

#### 流程整合

由上述可知，我们将各个系统分为不同的模块，同时为了简化问题，我们增加一个 common 模块。

各个模块中主要是围绕着各自的路由配置（routes）、store 配置、样式集、路由组件、apis 以及一些基础设施（常量、工具函数等）。

common 中包含公共的路由配置，root store 配置，各个系统中均使用的基础样式集、通用组件、bus、apis 等。

> 这个样式集其实还有个小问题，比如 A、B 模块都引用的一个样式集 x，但是这个样式集并不是所有都通用的，也就是并不是在 common 中。那这时候如何引用呢？
> 
> 如果 A、B 都直接引用的话，打包过后会冗余。这里给个基于 less 的思路：
> 
> - mixin 不导出
> - reference 引入
>
> 其它情况可能略有不同，但是可以借鉴。

这里需要注意 bus 和 apis，为了实现 pub/sub 模式（可以支持跨组件通信的一种方案），直接使用一个 bus，在各个系统中均引入 common 中的 bus。其中发出的事件如果是特有的，增加前缀 `${sysName}::`，如果是全局事件那就不需要加前缀。另外，严禁直接解绑所有事件监听，只管理自己申请的资源。

对于 apis，可能不同的系统会有不同的配置，如果有不同，直接采用 `axios.create` 创建一个新的实例，但是最好是使用的统一处理。common 中增加一个默认的实例。

另外，无论是开发/构建哪个系统，我们都走同一个入口（main.js），在这个入口中做一些初始化工作：

1. 引入 Vue、VueRouter、Vuex 等基本库
2. 集成 VueRouter、Vuex
3. 引入 common 中的 styles
4. 检测所处环境（SYS）
5. 根据环境，动态引入 common 以及其它的系统的路由配置和 store 配置
6. 根据环境，条件引入不同系统的样式
7. 初始化 Router 和 Store
8. 创建 Vue 实例，启动应用

为了支持一些初始化工作，common 以及其它系统中均可增加一个 mixin，可以支持初始化的一些特化工作。

> 这就是 common 模块所承载的另外一个含义 ———— 启动应用的入口。

*NOTICE* 最好的情况我认为是只能允许 不同系统中引入 common 里面的资源，不允许 common 引用其它系统中的资源。其它系统中的资源建议不能互相引入。

#### 备注

1. 假如需要一些模拟数据，比如菜单数据，可以在 common 模块或者其它相应模块中增加 `menu-${sysName}.json`，在 common 模块中按需引入（如果是全局资源）。
2. 其实 common 以及其它模块可以理解为配置，通过 `main.js` 将其规整起来。如果将 main 置于 common 中，那 common 又具备了应用启动的责任。
3. 为了简化操作逻辑，移除 `dev` 和 `build` 命令，但是增加 `dev:${sysName}`、`build:${sysName}` 命令
4. 使用 Vuex 时，在子模块中一定是 namespaced module，不然容易起冲突。虽然可以按照打包模式来进行区分，但是这样容易混乱。
5. 路由配置注意事项，子系统中路由最好加入 `${sysName}` 前缀，方便处理以及不冲突。（其实可以简单的配置不带前缀的路由配置，然后 递归处理一下就行了）
6. 开发环境中可能会存在 chunks 加载失败的问题
7. 菜单逻辑需要实际按情况处理。
8. 关于 code-split，直接按照路由进行划分（结合 webpack），目前懒得切分，后续可优化，很简单。
9. 建议服务端、前端很多都能保持一致。

## 总结

其实本文的主要目标是介绍 **基于 SSO、同一框架等约束条件下** 的插件化系统的前端设计，中间有很多注意点，也是一个小扩展和部分知识的整合应用。直接基于 SSO 的多站点模式和 iframe 模式其实也非常好用，看具体需要什么。

> 这两天由于业务需求，有个插件化系统前端设计，目前已出[一个方案](https://www.processon.com/diagraming/5b29ba32e4b025396184ae83)，这两天会验证，如果ok，会落地实践。

## Extensions

- upgrade
- seed project
- 考虑动态加载不同服务上的组件（注意stylesheet 和路由配置的动态注入）
    + [一个方案](https://www.processon.com/diagraming/5b29ba32e4b025396184ae83)
- 考虑定制化配置的结合
- 考虑不同的底层实现
- 结合动态按需加载和定制化配置实现系统可视化配置

## Refs

- [dynamic imports](https://webpack.js.org/guides/code-splitting/#dynamic-imports)
- [vue mixin](https://vuejs.org/v2/api/#mixins)
- [vuex namespaced module](https://vuex.vuejs.org/guide/modules.html#namespacing)
- [lazy loading routes](https://router.vuejs.org/guide/advanced/lazy-loading.html)
- [webpack code split](https://webpack.js.org/guides/code-splitting/#dynamic-imports)
